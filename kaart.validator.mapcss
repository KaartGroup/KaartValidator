meta
{
	title: "Validation rules for Kaart Group";
	version: "2018-11-07"
	description: "Check surfaces on roads that are residential and above, that _link destination:ref tags exist when it has a ref"
	author: "Taylor Smock";
}
/* Check that roads have surfaces */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][name][!surface]{
group: tr("kaart");
throwWarning: tr("Missing surface on road with name");
}
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][name][surface=paved]{
group: tr("kaart");
throwWarning: tr("Generic paved surface on road with name");
}
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][ref][!surface]{
group: tr("kaart");
throwWarning: tr("Missing surface on road with ref");
}

/* Check that roads have lanes */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|motorway_link|trunk_link|primary_link|secondary_link|tertiary_link)$/][!lanes][!lanes:forward][!lanes:backward]{
group: tr("kaart");
throwWarning: tr("Missing lanes on road");
}

/* Check *_links to make certain they have destination:ref */
way[highway=~/^.*_link$/][ref][!destination:ref] {
group: tr("kaart");
throwWarning: tr("Link has ref but no destination:ref");
fixChangeKey: "ref => destination:ref";
}

/* Check *_links to seeif they have a oneway tag */
way[highway=~/^.*_link$/][!oneway] {
group: tr("kaart");
throwWarning: tr("Links are usually oneways");
}

/* Check for oneway=-1 */
way[oneway=-1] {
throwWarning: tr("Oneways should not use -1. Reverse and use "yes");
}

way[highway=~/^.*_link$/] > node {set .is_in_link}
way[highway =~ /^(bus_guideway|living_street|motorway|motorway_link|pedestrian|primary|primary_link|raceway|residential|road|secondary|secondary_link|service|tertiary|tertiary_link|track|trunk|trunk_link|unclassified)$/] > node { set .is_in_major_road }
way[highway =~ /^(service)$/] > node { set .is_in_minor_road }

/* Mark _links without destination:ref */
way[highway=~/^.*_link$/][!destination:ref][!destination][!destination:street] {
group: tr("kaart");
throwWarning: tr("Link has no destination/:street/:ref tag");
}

/* Mark gas stations without a brand but with a common brand name */
*[amenity=fuel][name=~/(BP|Caltex|Engen|Sasol|Shell|Total)$/][!brand] {
group: tr("kaart");
throwWarning: tr("Gas station has a name but no brand");
fixChangeKey: "name => brand";
}

/* Mark gas stations without a brand */
*[amenity=fuel][name][!brand] {
group: tr("kaart");
throwWarning: tr("Gas station has a name but no brand");
}

/* Checks for roundabouts */
way[junction=roundabout] > node {set .is_in_roundabout}
node[traffic_calming=island] { set .is_traffic_calming_island}
way[highway][oneway!=yes][junction!=roundabout] > node.is_in_roundabout!.is_traffic_calming_island {
group: tr("kaart");
throwWarning: tr("Highway connecting to roundabout is NOT a oneway and the node is not a traffic calming island");
suggestAlternative: "Split ways to have roundabout flares or add traffic_calming=island to the node"
}

way[highway=~/(motorway|trunk|primary|secondary|tertiary|unclassified|residential|service|.*_link)$/][junction!=circular][junction!=roundabout]:closed {
group: tr("kaart");
throwWarning: tr("Possible roundabout or circular junction");
}

/* Check destination lane tagging */
/* Check toll roads */
*[destination:ref:lanes=~/(.*)toll(.*)$/] {
group: tr("kaart");
throwWarning: tr("Toll roads in destination:ref:lanes are lower case, instead of upper case");
fixAdd: concat("destination:ref:lanes=", replace(tag("destination:ref:lanes"), "toll", "Toll"));
}

*[destination:ref=~/(.*)toll(.*)$/] {
group: tr("kaart");
throwWarning: tr("Toll roads in destination:ref are lower case, instead of upper case");
fixAdd: concat("destination:ref=", replace(tag("destination:ref"), "toll", "Toll"));
}

*[destination:lanes:ref] {
group: tr("kaart");
throwWarning: tr("destination:lanes:ref should be destination:ref:lanes");
fixChangeKey: "destination:lanes:ref => destination:ref:lanes";
}

*[destination:lanes:ref:to] {
group: tr("kaart");
throwWarning: tr("destination:lanes:ref:to should be destination:ref:to:lanes");
fixChangeKey: "destination:lanes:ref:to => destination:ref:to:lanes";
}

/* TODO: Fix maxspeed */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][maxspeed] > node:connection { set .has_maxspeed }
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][!maxspeed] > node:connection { set .no_maxspeed }
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/] >[index=1] node.has_maxspeed { set .start_has_maxspeed }
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/] >[index=-1] node.has_maxspeed { set .end_has_maxspeed }

way[!maxspeed].start_has_maxspeed!.end_has_maxspeed,
way[!maxspeed]!.start_has_maxspeed.end_has_maxspeed,
way[!maxspeed].start_has_maxspeed.end_has_maxspeed {
group: tr("kaart");
throwOther: tr("Does the maxspeed continue here?");
}
/* Check bridge tagging */
way[bridge][!layer] {
group: tr("kaart");
throwWarning: tr("Bridges should have a layer");
fixAdd: "layer=1";
}

/* Check mini-roundabouts for the correct direction */
node[highway=mini_roundabout][direction!=clockwise]!:righthandtraffic {
group: tr("kaart");
throwWarning: tr("Mini-roundabouts should have a clockwise direction in this country");
fixAdd: "direction=clockwise";
}
node[highway=mini_roundabout][direction!=anticlockwise]:righthandtraffic {
group: tr("kaart");
throwWarning: tr("Mini-roundabouts should have a anticlockwise direction in this country");
fixAdd: "direction=anticlockwise";
}
