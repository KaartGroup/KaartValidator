meta
{
	title: "Validation rules for Kaart Group";
	version: "2018-11-20";
	description: "Various checks that are useful to Kaart";
	author: "Taylor Smock";
}
/* Documentation
 * https://josm.openstreetmap.de/wiki/Help/Validator/MapCSSTagChecker
 * https://josm.openstreetmap.de/wiki/Help/Styles/MapCSSImplementation
 */

/****************
 ** Roads *******
 ****************/
/* throw error on oneway=-1 */
way[oneway=-1] {
	group: tr("kaart");
	throwError: tr("oneway should not be -1");
	suggestAlternative: tr("oneway=yes and reverse the way");
}
/* Check that roads have surfaces */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][!surface],
way[highway=~/^.*_link$/][!surface] {
	group: tr("kaart");
	throwWarning: tr("Missing surface on road that is a {0}", tag("highway"));
}
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][surface=paved],
way[highway=~/^(pedestrian)$/][name][surface=paved],
way[highway=~/^.*_link$/][surface=paved] {
	group: tr("kaart");
	throwWarning: tr("Generic paved surface on road");
}

/* Check that roads have lanes */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|motorway_link|trunk_link|primary_link|secondary_link|tertiary_link)$/][!lanes][surface!~/^(gravel|ground)$/] {
	group: tr("kaart");
	throwWarning: tr("Missing lanes on road");
}

/* Check implied motorway tags */
way[highway=~/^(motorway|motorway_link)$/][!oneway] {
	group: tr("kaart");
	throwWarning: tr("{0} is typically {1}", "{0.tag}", "{1.key}");
	suggestAlternative: "oneway=yes";
}
way[highway=~/^(motorway|motorway_link)$/][!access] {
	group: tr("kaart");
	throwWarning: tr("{0} is typically {1}", "{0.tag}", "{1.key}");
	suggestAlternative: "access=no";
}
way[highway=~/^(motorway|motorway_link)$/][!motor_vehicle] {
	group: tr("kaart");
	throwWarning: tr("{0} is typically {1}", "{0.tag}", "{1.key}");
	suggestAlternative: "motor_vehicle=yes";
}

/* Check lanes from way to way (ONLY TWO WAYS) TODO check patches */
/* node[count(parent_osm_ids()) = 2 && count(parent_osm_ids("lanes")) != 0 && get(parent_osm_ids("lanes"),0) != get(parent_osm_ids("lanes"),1) && (regexp_match("(slight_right|slight_left|right|left)", get(parent_osm_ids("turn:lanes"))) != null )] {
 } */

/* Check that turn:lanes/:forward/:backward */
way[highway][turn:lanes][!oneway] {
	group: tr("kaart");
	throwWarning: tr("turn:lanes without oneway -- are turn lanes the same in both directions?");
}
way[highway][turn:lanes][turn:lanes:forward],
way[highway][turn:lanes][turn:lanes:backward] {
	group: tr("kaart");
	throwError: tr("turn:lanes and a directional turn:lanes");
}
way[highway][turn:lanes][oneway][count(split("|", tag("turn:lanes"))) != tag("lanes")],
way[highway][turn:lanes][!oneway][2 * count(split("|", tag("turn:lanes"))) != tag("lanes")],
way[highway][turn:lanes][!lanes] {
	group: tr("kaart");
	throwWarning: tr("turn:lanes do not match lanes");
	/*fixAdd: concat("lanes=", count(split("|", tag("turn.lanes")));*/
}
way[highway][turn:lanes:forward][lanes:forward][count(split("|", tag("turn:lanes:forward"))) != tag("lanes:forward")],
way[highway][turn:lanes:forward][!lanes:forward][count(split("|", tag("turn:lanes:forward"))) != tag("lanes") / 2] {
	group: tr("kaart");
	throwWarning: tr("turn:lanes:forward do not match lanes:forward");
	/*fixAdd: concat("lanes:forward=", count(split("|", tag("turn.lanes:forward")));*/
}
way[highway][turn:lanes:backward][lanes:backward][count(split("|", tag("turn:lanes:backward"))) != tag("lanes:backward")],
way[highway][turn:lanes:backward][!lanes:backward][count(split("|", tag("turn:lanes:backward"))) != tag("lanes") / 2] {
	group: tr("kaart");
	throwWarning: tr("turn:lanes:backward do not match lanes:backward");
	/*fixAdd: concat("lanes:backward=", count(split("|", tag("turn.lanes:backward")));*/
}

way[highway][turn],
way[highway][turn:forward],
way[highway][turn:backward],
way[highway][turn:both_ways] {
	group: tr("kaart");
	throwWarning: tr("We shoulding be using turn:<direction>");
	suggestAlternative: tr("turn:lanes:<direction>");
}

/* Check *_links to see if they have a oneway tag */
way[highway=~/^.*_link$/][!oneway] {
	group: tr("kaart");
	throwWarning: tr("Links are usually oneways, but there are some that are occasionally two-ways");
	suggestAlternative: tr("oneway=yes/no");
}

/* Check links to make certain they match the road they are going to TODO */
way[highway=~/^.*_link$/] >[index=-1] node { set .end_of_link }
way[highway=~/^.*_link$/] >[index=1] node { set .start_of_link }
node.end_of_link, node.start_of_link { set .link }
way[highway=motorway] > node.link { set .motorway }
way[highway=motorway_link] > node.link { set .motorway_link }
way[highway=trunk] > node.link { set .trunk }
way[highway=trunk_link] > node.link { set .trunk_link }
way[highway=primary] > node.link { set .primary }
way[highway=primary_link] > node.link { set .primary_link }
way[highway=secondary] > node.link { set .secondary }
way[highway=secondary_link] > node.link { set .secondary_link }
way[highway=tertiary] > node.link { set .tertiary }
way[highway=tertiary_link] > node.link { set .tertiary_link }

node.motorway!.motorway_link,
node.trunk!.motorway_link!.trunk_link,
node.primary!.motorway_link!.trunk_link!.primary_link,
node.secondary!.motorway_link!.trunk_link!.primary_link!.secondary_link,
node.tertiary!.motorway_link!.trunk_link!.primary_link!.secondary_link!.tertiary_link {
	group: tr("kaart");
	throwWarning: tr("Check the link and the highest road it goes to/comes from");
}

way >[index=-1] node {
	set .end_of_way
}
way >[index=1] node {
	set .start_of_way
}

/* Check ref consistency */
way[highway][ref] > node.end_of_way.start_of_way[count(parent_tags("ref")) != 1] { set .highway_break_ref }
node.highway_break_ref:in-downloaded-area {
	group: tr("kaart");
	throwWarning: tr("Does the ref really change here?");
}
way[highway=~/^(motorway|trunk|primary|secondary)$/][!ref] {
	group: tr("kaart");
	throwWarning: tr("A {0} road is missing a ref", tag("highway"));
}

/* Check name consistency */
way[highway][name] > node.end_of_way.start_of_way[count(parent_tags("name")) != 1] { set .highway_break_name }
node.highway_break_name:in-downloaded-area {
	group: tr("kaart");
	throwWarning: tr("Does the name really change here?");
}
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][!name] {
	group: tr("kaart");
	throwWarning: tr("A {0} road is missing a name", tag("highway"));
}

/* Check *_links to see if they have a name/noname tag */
way[highway=~/^.*_link$/][name],
way[highway=~/^.*_link$/][noname] {
	group: tr("kaart");
	throwWarning: tr("Links shouldn''t have name/noname tags");
}
/* Check that way that is ONLY connecting crossings is a footway TODO */
/*way[highway!=footway][!name] >[index=-1] node[highway=crossing] >[index=1] node[highway=crossing] {
	group: tr("kaart");
	throwWarning: tr("This should probably be a footway");
}*/
/* Check *_links and streets to find ways that split-end into _links TODO */
way[highway=~/^.*_link$/] >[index=-1] node,
way[highway=~/^.*_link$/] >[index=1] node{
	set .end_of_link
}
way[highway!~/^.*_link$/][name] >[index=-1] node,
way[highway!~/^.*_link$/][name] >[index=1] node {
	set .end_of_road
}

/* TODO When #16998 is closed, remove node.end_of_road.end_of_link */
node.end_of_road.end_of_link,
node[count(parent_osm_ids("highway")) == 1 && count(parent_osm_ids("highway", "^.*_link$")) == 2] {
	group: tr("kaart");
	throwWarning: tr("Should there be split _links at the end of a highway?");
}

way[highway=~/^.*_link$/] > node {set .is_in_link}
way[highway =~ /^(bus_guideway|living_street|motorway|motorway_link|pedestrian|primary|primary_link|raceway|residential|road|secondary|secondary_link|service|tertiary|tertiary_link|track|trunk|trunk_link|unclassified)$/] > node { set .is_in_major_road }
way[highway =~ /^(service)$/] > node { set .is_in_minor_road }

/* TODO: Fix maxspeed maybe parent_tags(key_name) with has_tag_key? */
way[highway][maxspeed] >[index=1] node,
way[highway][maxspeed] >[index=-1] node { set .has_maxspeed }
way[highway][!maxspeed] >[index=1] node,
way[highway][!maxspeed] >[index=-1] node { set .no_maxspeed }
way[highway] <[index=1] node.has_maxspeed { set .start_has_maxspeed }
way[highway] <[index=-1] node.has_maxspeed { set .end_has_maxspeed }

node.no_maxspeed.has_maxspeed[count(parent_tags("name")) = 1]:in-downloaded-area,
node.no_maxspeed.has_maxspeed[count(parent_tags("ref")) = 1]:in-downloaded-area {
	group: tr("kaart");
	throwWarning: tr("We go from maxspeed to no maxspeed");
}

way[!maxspeed].start_has_maxspeed!.end_has_maxspeed,
way[!maxspeed]!.start_has_maxspeed.end_has_maxspeed,
way[!maxspeed].start_has_maxspeed.end_has_maxspeed {
	group: tr("kaart");
	throwWarning: tr("Does the maxspeed continue here?");
}
/* Check bridge tagging */
way[highway][bridge][!layer] {
	group: tr("kaart");
	throwWarning: tr("Bridges should have a layer");
	fixAdd: "layer=1";
}

/* Check for potential road restrictions */
way[highway][bridge][!maxweight] {
	group: tr("kaart");
	throwOther: tr("Bridges may have a maxweight");
	suggestAlternative: "maxweight";
}
/* TODO fix */
way[highway][bridge] ⧉ way[highway][!bridge][!maxheight] {
	group: tr("kaart");
	throwOther: tr("Ways under bridges occassionally have a maxheight attribute. Check on ground for the information (or OpenStreetCam/Mapillary)");
	suggestAlternative: "maxheight";
}
way[highway][tunnel] {
	group: tr("kaart");
	throwOther: tr("Tunnels may have a maxheight");
	suggestAlternative: "maxheight";
}
/* Check mini-roundabouts for the correct direction */
node[highway=mini_roundabout][direction!=clockwise]!:righthandtraffic {
	group: tr("kaart");
	throwWarning: tr("Mini-roundabouts should have a clockwise direction in this country");
	fixAdd: "direction=clockwise";
}
node[highway=mini_roundabout][direction!=anticlockwise]:righthandtraffic {
	group: tr("kaart");
	throwWarning: tr("Mini-roundabouts should have a anticlockwise direction in this country");
	fixAdd: "direction=anticlockwise";
}

/*****************
 * Roundabouts ***
 *****************/
/* Checks for roundabouts */
way[junction=roundabout] > node {set .is_in_roundabout}
node[traffic_calming=island] { set .is_traffic_calming_island}
way[highway][oneway!=yes][junction!=roundabout] > node.is_in_roundabout!.is_traffic_calming_island {
	group: tr("kaart");
	throwWarning: tr("Highway connecting to roundabout is NOT a oneway -- check if there is a traffic_calming=island nearby");
	suggestAlternative: "split ways to have roundabout flares or add traffic_calming=island to a node using imagery"
}
way[highway][oneway!=yes][junction!=roundabout] > node.is_in_roundabout.is_traffic_calming_island {
	group: tr("kaart");
	throwWarning: tr("The node where a roundabout and a way connect should NOT be a traffic_calming=island (the island should be on the approach, not in the roundabout)");
}

/* Check for roundabouts with MORE than 1 road entering at the same location */
way[junction=roundabout][name] > node {set .is_in_named_roundabout}
/* TODO remove the one with parent_tags as soon as parent_osm_ids is in josm-tested */
node.is_in_roundabout!.is_in_named_roundabout[count(parent_tags("name")) > 1],
node.is_in_roundabout.is_in_named_roundabout[count(parent_tags("name")) > 2] {
	group: tr("kaart");
	throwWarning: tr("Roundabouts should not have more than two additional ways at any node");
}
node.is_in_roundabout[count(parent_osm_ids("highway")) - count(parent_osm_ids("junction")) > 1] {
	group: tr("kaart");
	throwError: tr("Roundabouts should not have more than two additional ways at any node");
}

/* Ways entering the roundabout should start/end there */
way[name][!junction] > node.is_in_roundabout!.end_of_way!.start_of_way { set .roundabout_way_ends }
node.roundabout_way_ends {
	group: tr("kaart");
	throwWarning: tr("Way {0} does not end at roundabout", parent_tags("name"));
}

way[highway=~/(motorway|trunk|primary|secondary|tertiary|unclassified|residential|service|.*_link)$/][junction!=circular][junction!=roundabout]:closed {
	group: tr("kaart");
	throwWarning: tr("Possible roundabout or circular junction");
}

way[highway=~/^.*_link$/][junction] {
	group: tr("kaart");
	throwWarning: tr("{0} should not be a {1}", tag("junction"), tag("highway"));
}


/***********************
 ** Country Specific ***
 ***********************/
/* Copy name to name:<appropriate> */
*[name=~/^(.*)(Α|α|ά|Β|β|Γ|γ|Δ|δ|Ε|ε|έ|Ζ|ζ|Η|η|Θ|θ|Ι|ι|ί|Κ|κ|Λ|λ|Μ|μ|Ν|ν|Ξ|ξ|Ο|ο|Π|π|Ρ|ρ|Σ|σ|ς|Τ|τ|Υ|υ|Φ|φ|Χ|χ|Ψ|ψ|Ω|ω)+(.*)$/][!name:el][inside("GR")] { set .needsgreekname }
/* Check end of names for σ instead of ς */
*[name=~/^(.*)(σ) (.*)$/],
*[name=~/^(.*)(σ)$/],
*[name=~/^(σ)$/] {
	group: tr("kaart");
	throwError: tr("σ should be ς at the end of words");
	assertMatch: "way highway=primary name=\"Φεσσασ\"";
	assertMatch: "way highway=primary name=\"Φεσσασ Φεσσας\"";
	assertNoMatch: "way highway=primary name=\"Φεσσας\"";
	assertNoMatch: "way highway=primary name=\"Φεσσας Φεσσας\"";
}
way[highway].needsgreekname,
*[name].needsgreekname:modified,
*[name].needsgreekname:selected {
	group: tr("kaart");
	throwWarning: tr("There should be a name:el tag");
	fixAdd: concat("name:", "el", "=", tag(name));
}

way[highway][!name][name:el][inside("GR")] {
	group: tr("kaart");
	throwWarning: tr("There should be a name tag");
	fixAdd: concat("name", "=", tag(name:el));
}
way[highway][name=~/^.*((ΑΕΙ|ΑΤ|ΑΤΕΙ|Αγ|Αλ|Αφοι|Αφών|Β|Βασ|Γρ|Δ|ΔΣ|Δημ|ΕΛΤΑ|Εθν|Ελ|Θεσ|Ι[. ]?Μ|Ι[. ]?Ν|Κτ|Κων|Λ|Ν|Ορ|Π|Παν|Πλ|Ποτ|Στρ|Σχ|ΤΕΙ|νικης|ωου)[.]?)$/][inside("GR")] {
	group: tr("kaart");
	throwWarning: tr("We don''t want to use abbreviations for streets");
}

/* Transliteration */
way[highway][name=~/^(.*)(Α|α|ά|Β|β|Γ|γ|Δ|δ|Ε|ε|έ|Ζ|ζ|Η|η|Θ|θ|Ι|ι|ί|Κ|κ|Λ|λ|Μ|μ|Ν|ν|Ξ|ξ|Ο|ο|Π|π|Ρ|ρ|Σ|σ|ς|Τ|τ|Υ|υ|Φ|φ|Χ|χ|Ψ|ψ|Ω|ω)+(.*)$/][!int_name][inside("GR")]:selected {
	group: tr("kaart");
	throwWarning: tr("There should be an int_name");
	/* Transliteration is a different step */
	fixAdd: concat("int_name=", tag("name"));
}
/* Greece transliteration */
way[highway][int_name=~/^(.*)(Α|α|ά|Β|β|Γ|γ|Δ|δ|Ε|ε|έ|Ζ|ζ|Η|η|Θ|θ|Ι|ι|ί|Κ|κ|Λ|λ|Μ|μ|Ν|ν|Ξ|ξ|Ο|ο|Π|π|Ρ|ρ|Σ|σ|ς|Τ|τ|Υ|υ|Φ|φ|Χ|χ|Ψ|ψ|Ω|ω)+(.*)$/][inside("GR")]:selected {
	group: tr("kaart");
	throwWarning: tr("int_name should not be the local greece name");
	fixAdd: concat("int_name=",
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	tag("int_name"),
	"Α", "A"), "α", "a"), "ά", "a"),
	"Β", "B"), "β", "b"),
	"Γ", "G"), "γ", "g"),
	"Δ", "D"), "δ", "d"),
	"Ε", "E"), "ε", "e"), "έ", "e"),
	"Ζ", "Z"), "ζ", "z"),
	"Θ", "Th"), "θ", "th"),
	"Ι", "I"), "ι", "i"), "ί", "i"),
	"Κ", "K"), "κ", "k"),
	"Λ", "L"), "λ", "l"),
	"Μ", "M"), "μ", "m"),
	"Ν", "N"), "ν", "n"),
	"Ξ", "X"), "ξ", "x"),
	"Ο", "O"), "ο", "o"),
	"Π", "P"), "π", "p"),
	"Ρ", "R"), "ρ", "r"),
	"Σ", "S"), "σ", "s"), "ς", "s"),
	"Τ", "t"), "τ", "t"),
	"Υ", "U"), "υ", "u"),
	"Φ", "Ph"), "φ", "ph"),
	"Χ", "Ch"), "χ", "ch"),
	"Ψ", "Ps"), "ψ", "ps"),
	"Ω", "O"), "ω", "o")); /* May be \bar{o} */
	/*"Η", "TODO"),*/
	/*"η", "TODO"),*/
}

/* OSM Greece does NOT want street/road */
way[highway][name=~/(?i)(?u).*(Οδός|Odos|Λεωφόρος|avenue|street|road|str\.).*/][inside("GR")],
way[highway][name:en=~/(?i).*(avenue|street|road|str\.)$/],
way[highway][name:el=~/(?i)(?u).*(Οδός|Odos|Λεωφόρος).*$/] {
	group: tr("kaart");
	throwWarning: "OSM Greece does not want street/road/other prefixes -- try removing the prefix (fix won't work with different cases)";
	fixAdd: concat("name=", trim(replace(tag("name"), "Οδός", "")));
	fixAdd: concat("name=", trim(replace(tag("name"), "Odos", "")));
	fixAdd: concat("name=", trim(replace(tag("name"), "Λεωφόρος", "")));
	fixAdd: concat("name:el=", trim(replace(tag("name:el"), "Οδός", "")));
	fixAdd: concat("name:el=", trim(replace(tag("name:el"), "Odos", "")));
	fixAdd: concat("name:el=", trim(replace(tag("name:el"), "Λεωφόρος", "")));
	fixAdd: concat("name=", trim(replace(tag("name"), "street", "")));
	fixAdd: concat("name=", trim(replace(tag("name"), "str.", "")));
	fixAdd: concat("name=", trim(replace(tag("name"), "avenue", "")));
	fixAdd: concat("name=", trim(replace(tag("name"), "road", "")));
	fixAdd: concat("name:en=", trim(replace(tag("name:en"), "street", "")));
	fixAdd: concat("name:en=", trim(replace(tag("name:en"), "str.", "")));
	fixAdd: concat("name:en=", trim(replace(tag("name:en"), "avenue", "")));
	fixAdd: concat("name:en=", trim(replace(tag("name:en"), "road", "")));
	/*assertMatch: "way highway=primary name=\"Φεσσασ Οδός\"";*/
}

/***************
 * Misc ********
 ***************/

/* Check for pedestrian ways */
node[crossing] { set .crossing_node }
way[highway=~/^(cycleway|footway|pedestrian)$/][footway=crossing] > node { set .footway_crossing }
way[highway][oneway=yes] > node { set .possible_divided_highway }
way[highway!~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][waylength() < 35] > node.crossing_node.possible_divided_highway!.footway_crossing,
way[!highway][waylength() < 30] > node.crossing_node.possible_divided_highway!.footway_crossing {
	group: tr("kaart");
	throwWarning: tr("Possible pedestrian crossing");
	suggestAlternative: tr("highway=footway, footway=crossing");
}
node.crossing_node.possible_divided_highway!.footway_crossing {
	group: tr("kaart");
	throwWarning: tr("Maybe add a pedestrian crossing here");
	suggestAlternative: tr("highway=footway, footway=crossing");
}
/* Check for address tagging */
*[addr:housenumber][!addr:street]:modified {
	group: tr("kaart");
	throwError: tr("Addresses should have a street");
	suggestAlternative: tr("addr:street");
}


/***********
 ** POI ****
 ***********/
/* Gas stations */
/* Mark gas stations without a brand but with a common brand name */
*[amenity=fuel][name=~/(BP|Caltex|Engen|Sasol|Shell|Total)$/][!brand] {
	group: tr("kaart");
	throwWarning: tr("Gas station has a name but no brand");
	fixAdd: concat("brand=", tag("name"));
}

node[amenity=fuel]:modified {
	group: tr("kaart");
	throwWarning: tr("Gas stations should be an area, not a node");
}

/* Mark gas stations without a brand */
*[amenity=fuel][name][!brand] {
	group: tr("kaart");
	throwWarning: tr("Gas station has a name but no brand");
}

node[amenity=fuel][!name][!brand][fixme!=name] {
	group: tr("kaart");
	throwWarning: tr("Gas station should have either a brand or a name");
}

/* Check for names on POI's */
*[amenity=~/^(school|kindergarten|university|college|hospital|clinic|doctors|dentist|bank|courthouse|police|fire_station|place_of_worship)$/][!name][fixme!=name],
*[amenity=~/^(school|kindergarten|university|college|hospital|clinic|doctors|dentist|bank|courthouse|police|fire_station|place_of_worship)$/][!name]:modified {
	group: tr("kaart");
	throwWarning: tr("{0} should have a name or a fixme=name", tag("amenity"));
}
*[office=~/^(government)$/][!name][fixme!=name],
*[office=~/^(government)$/][!name]:modified {
	group: tr("kaart");
	throwWarning: tr("{0} should have a name or a fixme=name", tag("office"));
}
*[tourism=~/^(hotel)$/][!name][fixme!=name],
*[tourism=~/^(hotel)$/][!name]:modified {
	group: tr("kaart");
	throwWarning: tr("{0} should have a name or a fixme=name", tag("tourism"));
}

*[fixme=~/^.*[ A-Z]+.*$/]:modified,
*[fixme][fixme!~/^[a-z]*$/]:modified {
	group: tr("kaart");
	throwError: tr("fixme should ONLY be a tag");
	suggestAlternative: tr("note");
	assertMatch: "way fixme=\"bad name\"";
	assertNoMatch: "way fixme=\"name\"";
	assertMatch: "way fixme=\"Name\"";
}

/**************************************
 ***** Destination Tagging ************
 **************************************/
/* Check destination lane tagging */
/* Check toll roads */
*[destination:ref:lanes=~/(.*)toll(.*)$/] {
	group: tr("kaart");
	throwWarning: tr("Toll roads in destination:ref:lanes are lower case, instead of upper case");
	fixAdd: concat("destination:ref:lanes=", replace(tag("destination:ref:lanes"), "toll", "Toll"));
}

*[destination:ref=~/(.*)toll(.*)$/] {
	group: tr("kaart");
	throwWarning: tr("Toll roads in destination:ref are lower case, instead of upper case");
	fixAdd: concat("destination:ref=", replace(tag("destination:ref"), "toll", "Toll"));
}

*[destination:lanes:ref] {
	group: tr("kaart");
	throwWarning: tr("destination:lanes:ref should be destination:ref:lanes");
	fixChangeKey: "destination:lanes:ref => destination:ref:lanes";
}

*[destination:lanes:ref:to] {
	group: tr("kaart");
	throwWarning: tr("destination:lanes:ref:to should be destination:ref:to:lanes");
	fixChangeKey: "destination:lanes:ref:to => destination:ref:to:lanes";
}
/* Check *_links to make certain they have destination:ref */
way[highway=~/^.*_link$/][ref][!destination:ref] {
	group: tr("kaart");
	throwWarning: tr("Link has ref but no destination:ref");
	fixChangeKey: "ref => destination:ref";
}
/* Check if *_links are appropriately ref'd */
way[highway!~/^.*_link$/][ref] > node.end_of_link { set .has_ref }
way[highway=~/^.*_link$/][destination:ref] > node.end_of_link { set .has_destination_ref }

/* TODO figure out way to select the _link */
/*node.end_of_link.has_ref < way[highway] {*/
/*fixAdd: concat("destination:ref=", parent_tag("ref"));*/

node.end_of_link.has_ref[parent_tag("ref") != parent_tag("destination:ref")] {
	group: tr("kaart");
	throwWarning: tr("The destination:ref tag ({0}) does not match the ref tag ({1})", parent_tag("destination:ref"), parent_tag("ref"));
}
node.end_of_link.has_destination_ref[get(parent_tags("destination:ref"),0) != get(parent_tags("destination:ref"),1)] {
	group: tr("kaart");
	throwWarning: tr("The destination:ref tag ({0}) does not match the ref tag ({1})", get(parent_tags("destination:ref"),0), get(parent_tags("destination:ref"),1));
}

/* Mark _links without destination/:ref/:street/:reg_ref */
way[highway=~/^.*_link$/][!destination][!destination:ref][!destination:street][!destination:reg_ref] {
	group: tr("kaart");
	throwWarning: tr("Link has no destination/:street/:ref tag");
}

/* Ensure that the destination:lanes/:forward/:backward match the number of lanes on the road */
way[highway][!lanes][destination:lanes] {
	group: tr("kaart");
	throwWarning: tr("There should be a lanes tag when there is a destination:lanes tag");
}
way[highway][lanes][destination:lanes][oneway][count(split("|", tag("destination:lanes"))) != tag("lanes")],
way[highway][lanes:forward][destination:lanes:forward][oneway][count(split("|", tag("destination:lanes:forward"))) != tag("lanes:forward")],
way[highway][!lanes:forward][destination:lanes:forward][count(split("|", tag("destination:lanes:forward"))) != tag("lanes") / 2],
way[highway][lanes:backward][destination:lanes:backward][oneway][count(split("|", tag("destination:lanes:backward"))) != tag("lanes:backward")],
way[highway][!lanes:backward][destination:lanes:backward][count(split("|", tag("destination:lanes:backward"))) != tag("lanes") / 2],
way[highway][lanes][destination:ref:lanes][oneway][count(split("|", tag("destination:ref:lanes"))) != tag("lanes")],
way[highway][lanes:forward][destination:ref:lanes:forward][oneway][count(split("|", tag("destination:ref:lanes:forward"))) != tag("lanes:forward")],
way[highway][!lanes:forward][destination:ref:lanes:forward][count(split("|", tag("destination:ref:lanes:forward"))) != tag("lanes") / 2],
way[highway][lanes:backward][destination:ref:lanes:backward][oneway][count(split("|", tag("destination:ref:lanes:backward"))) != tag("lanes:backward")],
way[highway][!lanes:backward][destination:ref:lanes:backward][count(split("|", tag("destination:ref:lanes:backward"))) != tag("lanes") / 2] {
	group: tr("kaart");
	throwWarning: tr("{0} does not match {1}", "{2.tag}", "{1.tag}");
}
*[destination=~/^.*(?i)(ave|blvd|str).*$/],
*[destination:to=~/^.*(?i)(ave|blvd|str).*$/],
*[destination:street=~/^.*(?i)(ave|blvd|str).*$/],
*[destination:lanes=~/^.*(?i)(ave|blvd|str).*$/] {
	group: tr("kaart");
	throwWarning: tr("{0} shouldn''t have a street abbreviation in {1}", tag("name"), "{0.key}");
	/*fixAdd: concat("{0.key}=",
replace(replace(replace(replace(replace(replace(replace(replace(
tr("{0}", "{0.key}"),
"ave", "Avenue"),
"ave.", "Avenue"),
"Ave", "Avenue"),
"Ave.", "Avenue"),
"blvd", "Boulevard"),
"blvd.", "Boulevard"),
"Blvd", "Boulevard"),
"Blvd.", "Boulevard")
);*/
}
