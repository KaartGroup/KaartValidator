meta
{
	title: "Validation rules for Kaart Group";
	version: "2018-11-15";
	description: "Check surfaces on roads that are residential and above, that _link destination:ref tags exist when it has a ref";
	author: "Taylor Smock";
}
/* Documentation
 * https://josm.openstreetmap.de/wiki/Help/Validator/MapCSSTagChecker
 * https://josm.openstreetmap.de/wiki/Help/Styles/MapCSSImplementation
 */

/* Check that roads have surfaces */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][!surface],
way[highway=~/^.*_link$/][!surface] {
	group: tr("kaart");
	throwWarning: tr("Missing surface on road with name or ref");
}
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][surface=paved],
way[highway=~/^(pedestrian)$/][name][surface=paved],
way[highway=~/^.*_link$/][surface=paved] {
	group: tr("kaart");
	throwWarning: tr("Generic paved surface on road");
}

/* Check that roads have lanes */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|motorway_link|trunk_link|primary_link|secondary_link|tertiary_link)$/][!lanes][surface!~/^(gravel|ground)$/] {
	group: tr("kaart");
	throwWarning: tr("Missing lanes on road");
}

/* Check lanes from way to way (ONLY TWO WAYS) TODO check patches */
/* node[count(parent_osm_ids()) = 2 && count(parent_osm_ids("lanes")) != 0 && get(parent_osm_ids("lanes"),0) != get(parent_osm_ids("lanes"),1) && (regexp_match("(slight_right|slight_left|right|left)", get(parent_osm_ids("turn:lanes"))) != null )] {
 } */

/* Check that turn:lanes/:forward/:backward */
way[highway][turn:lanes][!oneway] {
	group: tr("kaart");
	throwWarning: tr("turn:lanes without oneway -- are turn lanes the same in both directions?");
}
way[highway][turn:lanes][turn:lanes:forward],
way[highway][turn:lanes][turn:lanes:backward] {
	group: tr("kaart");
	throwError: tr("turn:lanes and a directional turn:lanes");
}
way[highway][turn:lanes][oneway][count(split("|", tag("turn:lanes"))) != tag("lanes")],
way[highway][turn:lanes][!oneway][2 * count(split("|", tag("turn:lanes"))) != tag("lanes")],
way[highway][turn:lanes][!lanes] {
	group: tr("kaart");
	throwWarning: tr("turn:lanes do not match lanes");
	/*fixAdd: concat("lanes=", count(split("|", tag("turn.lanes")));*/
}
way[highway][turn:lanes:forward][lanes:forward][count(split("|", tag("turn:lanes:forward"))) != tag("lanes:forward")],
way[highway][turn:lanes:forward][!lanes:forward][count(split("|", tag("turn:lanes:forward"))) != tag("lanes") / 2] {
	group: tr("kaart");
	throwWarning: tr("turn:lanes:forward do not match lanes:forward");
	/*fixAdd: concat("lanes:forward=", count(split("|", tag("turn.lanes:forward")));*/
}
way[highway][turn:lanes:backward][lanes:backward][count(split("|", tag("turn:lanes:backward"))) != tag("lanes:backward")],
way[highway][turn:lanes:backward][!lanes:backward][count(split("|", tag("turn:lanes:backward"))) != tag("lanes") / 2] {
	group: tr("kaart");
	throwWarning: tr("turn:lanes:backward do not match lanes:backward");
	/*fixAdd: concat("lanes:backward=", count(split("|", tag("turn.lanes:backward")));*/
}

way[highway][turn],
way[highway][turn:forward],
way[highway][turn:backward],
way[highway][turn:both_ways] {
	group: tr("kaart");
	throwWarning: tr("We shoulding be using turn:<direction>.");
	suggestAlternative: tr("Try using turn:lanes:<direction> instead.");
}

/* Check *_links to make certain they have destination:ref */
way[highway=~/^.*_link$/][ref][!destination:ref] {
	group: tr("kaart");
	throwWarning: tr("Link has ref but no destination:ref");
	fixChangeKey: "ref => destination:ref";
}

/* Check *_links to see if they have a oneway tag */
way[highway=~/^.*_link$/][!oneway] {
group: tr("kaart");
throwWarning: tr("Links are usually oneways");
}

/* Check links to make certain they match the road they are going to TODO */
way[highway=~/^.*_link$/] >[index=-1] node { set .end_of_link }
way[highway=~/^.*_link$/] >[index=1] node { set .start_of_link }
node.end_of_link, node.start_of_link { set .link }
way[highway=motorway] > node.link { set .motorway }
way[highway=motorway_link] > node.link { set .motorway_link }
way[highway=trunk] > node.link { set .trunk }
way[highway=trunk_link] > node.link { set .trunk_link }
way[highway=primary] > node.link { set .primary }
way[highway=primary_link] > node.link { set .primary_link }
way[highway=secondary] > node.link { set .secondary }
way[highway=secondary_link] > node.link { set .secondary_link }
way[highway=tertiary] > node.link { set .tertiary }
way[highway=tertiary_link] > node.link { set .tertiary_link }

node.motorway!.motorway_link,
node.trunk!.motorway_link!.trunk_link,
node.primary!.motorway_link!.trunk_link!.primary_link,
node.secondary!.motorway_link!.trunk_link!.primary_link!.secondary_link,
node.tertiary!.motorway_link!.trunk_link!.primary_link!.secondary_link!.tertiary_link {
	group: tr("kaart");
	throwWarning: tr("Check the link and the highest road it goes to/comes from");
}

/* Check if *_links are appropriately ref'd */
way[highway!~/^.*_link$/][ref] > node.end_of_link { set .has_ref }
way[highway=~/^.*_link$/][destination:ref] > node.end_of_link { set .has_destination_ref }

/* TODO figure out way to select the _link */
/*node.end_of_link.has_ref < way[highway] {*/
/*fixAdd: concat("destination:ref=", parent_tag("ref"));*/

node.end_of_link.has_ref[parent_tag("ref") != parent_tag("destination:ref")] {
	group: tr("kaart");
	throwWarning: tr("The destination:ref tag ({0}) does not match the ref tag ({1})", parent_tag("destination:ref"), parent_tag("ref"));
}
node.end_of_link.has_destination_ref[get(parent_tags("destination:ref"),0) != get(parent_tags("destination:ref"),1)] {
	group: tr("kaart");
	throwWarning: tr("The destination:ref tag ({0}) does not match the ref tag ({1})", get(parent_tags("destination:ref"),0), get(parent_tags("destination:ref"),1));
}

way >[index=-1] node {
	set .end_of_way
}
way >[index=1] node {
	set .start_of_way
}

/* Check ref consistency */
way[highway][ref] > node.end_of_way.start_of_way[count(parent_tags("ref")) != 1] { set .highway_break_ref }
node.highway_break_ref {
	group: tr("kaart");
	throwWarning: tr("Does the ref really change from {0} to {1}", get(parent_tags("ref"),0), get(parent_tags("ref"),1));
}

/* Check name consistency */
way[highway][name] > node.end_of_way.start_of_way[count(parent_tags("name")) != 1] { set .highway_break_name }
node.highway_break_name {
	group: tr("kaart");
	throwWarning: tr("Does the name really change from {0} to {1}", get(parent_tags("name"),0), get(parent_tags("name"),1));
}

/* Check *_links to see if they have a name/noname tag */
way[highway=~/^.*_link$/][name],
way[highway=~/^.*_link$/][noname] {
	group: tr("kaart");
	throwWarning: tr("Links shouldn''t have name/noname tags");
}
/* Check that way that is ONLY connecting crossings is a footway TODO */
/*way[highway!=footway][!name] >[index=-1] node[highway=crossing] >[index=1] node[highway=crossing] {
	group: tr("kaart");
	throwWarning: tr("This should probably be a footway");
}*/
/* Check *_links and streets to find ways that split-end into _links TODO */
way[highway=~/^.*_link$/] >[index=-1] node,
way[highway=~/^.*_link$/] >[index=1] node{
	set .end_of_link
}
way[highway!~/^.*_link$/][name] >[index=-1] node,
way[highway!~/^.*_link$/][name] >[index=1] node {
	set .end_of_road
}

node.end_of_road.end_of_link {
	group: tr("kaart");
	throwWarning: tr("Should there be split _links at the end of a highway?");
}
/* Check for oneway=-1 */
way[oneway=-1] {
	throwWarning: tr("Oneways should not use -1. Reverse and use "yes");
}

way[highway=~/^.*_link$/] > node {set .is_in_link}
way[highway =~ /^(bus_guideway|living_street|motorway|motorway_link|pedestrian|primary|primary_link|raceway|residential|road|secondary|secondary_link|service|tertiary|tertiary_link|track|trunk|trunk_link|unclassified)$/] > node { set .is_in_major_road }
way[highway =~ /^(service)$/] > node { set .is_in_minor_road }

/* Mark _links without destination/:ref/:street/:reg_ref */
way[highway=~/^.*_link$/][!destination][!destination:ref][!destination:street][!destination:reg_ref] {
	group: tr("kaart");
	throwWarning: tr("Link has no destination/:street/:ref tag");
}

/* Copy name to name:<appropriate> */
*[name=~/^(.*)(Α|α|ά|Β|β|Γ|γ|Δ|δ|Ε|ε|έ|Ζ|ζ|Η|η|Θ|θ|Ι|ι|ί|Κ|κ|Λ|λ|Μ|μ|Ν|ν|Ξ|ξ|Ο|ο|Π|π|Ρ|ρ|Σ|σ|ς|Τ|τ|Υ|υ|Φ|φ|Χ|χ|Ψ|ψ|Ω|ω)+(.*)$/][!name:el][inside("GR")] { set .needsgreekname }
/* TODO check end of names for σ instead of ς */
*[name=~/^(.*)(σ) (.*)$/],
*[name=~/^(.*)(σ)$/],
*[name=~/^(σ)$/] {
	group: tr("kaart");
	throwError: tr("σ should be ς at the end of words");
	assertMatch: "way highway=primary name=\"Φεσσασ\"";
}
way[highway].needsgreekname,
*[name].needsgreekname:modified,
*[name].needsgreekname:selected {
	group: tr("kaart");
	throwWarning: tr("There should be a name:el tag");
	fixAdd: concat("name:", "el", "=", tag(name));
}

way[highway][!name][name:el][inside("GR")] {
	group: tr("kaart");
	throwWarning: tr("There should be a name tag");
	fixAdd: concat("name", "=", tag(name:el));
}

/* Transliteration */
way[highway][name=~/^(.*)(Α|α|ά|Β|β|Γ|γ|Δ|δ|Ε|ε|έ|Ζ|ζ|Η|η|Θ|θ|Ι|ι|ί|Κ|κ|Λ|λ|Μ|μ|Ν|ν|Ξ|ξ|Ο|ο|Π|π|Ρ|ρ|Σ|σ|ς|Τ|τ|Υ|υ|Φ|φ|Χ|χ|Ψ|ψ|Ω|ω)+(.*)$/][!int_name][inside("GR")]:selected {
	group: tr("kaart");
	throwWarning: tr("There should be an int_name");
	/* Transliteration is a different step */
	fixAdd: concat("int_name=", tag("name"));
}
/* Greece transliteration */
way[highway][int_name=~/^(.*)(Α|α|ά|Β|β|Γ|γ|Δ|δ|Ε|ε|έ|Ζ|ζ|Η|η|Θ|θ|Ι|ι|ί|Κ|κ|Λ|λ|Μ|μ|Ν|ν|Ξ|ξ|Ο|ο|Π|π|Ρ|ρ|Σ|σ|ς|Τ|τ|Υ|υ|Φ|φ|Χ|χ|Ψ|ψ|Ω|ω)+(.*)$/][inside("GR")]:selected {
	group: tr("kaart");
	throwWarning: tr("int_name should not be the local greece name");
	fixAdd: concat("int_name=",
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
	tag("int_name"),
	"Α", "A"), "α", "a"), "ά", "a"),
	"Β", "B"), "β", "b"),
	"Γ", "G"), "γ", "g"),
	"Δ", "D"), "δ", "d"),
	"Ε", "E"), "ε", "e"), "έ", "e"),
	"Ζ", "Z"), "ζ", "z"),
	"Θ", "Th"), "θ", "th"),
	"Ι", "I"), "ι", "i"), "ί", "i"),
	"Κ", "K"), "κ", "k"),
	"Λ", "L"), "λ", "l"),
	"Μ", "M"), "μ", "m"),
	"Ν", "N"), "ν", "n"),
	"Ξ", "X"), "ξ", "x"),
	"Ο", "O"), "ο", "o"),
	"Π", "P"), "π", "p"),
	"Ρ", "R"), "ρ", "r"),
	"Σ", "S"), "σ", "s"), "ς", "s"),
	"Τ", "t"), "τ", "t"),
	"Υ", "U"), "υ", "u"),
	"Φ", "Ph"), "φ", "ph"),
	"Χ", "Ch"), "χ", "ch"),
	"Ψ", "Ps"), "ψ", "ps"),
	"Ω", "O"), "ω", "o")); /* May be \bar{o} */
	/*"Η", "TODO"),*/
	/*"η", "TODO"),*/
}

/* OSM Greece does NOT want street/road TODO fix */
way[highway][name=~/(?i)(.*)(Οδός|Odos|Λεωφόρος|avenue|street|road|str\.)$/][inside("GR")]:modified,
way[highway][name:en=~/(?i)(.*)(avenue|street|road|str\.)$/][inside("GR")]:modified,
way[highway][name:el=~/(?i)(.*)(Οδός|Odos|Λεωφόρος)$/][inside("GR")]:modified {
	group: tr("kaart");
	throwWarning: "OSM Greece does not want street/road/other prefixes";
	fixAdd: concat("name:en=", trim(replace(tag("name:en"), "street", "")));
	fixAdd: concat("name:en=", trim(replace(tag("name:en"), "str.", "")));
	fixAdd: concat("name:en=", trim(replace(tag("name:en"), "avenue", "")));
	fixAdd: concat("name:en=", trim(replace(tag("name:en"), "road", "")));
}
/* Mark gas stations without a brand but with a common brand name */
*[amenity=fuel][name=~/(BP|Caltex|Engen|Sasol|Shell|Total)$/][!brand] {
	group: tr("kaart");
	throwWarning: tr("Gas station has a name but no brand");
	fixAdd: concat("brand=", tag("name"));
}

node[amenity=fuel]:modified {
	group: tr("kaart");
	throwWarning: tr("Gas stations should be an area, not a node");
}

/* Mark gas stations without a brand */
*[amenity=fuel][name][!brand] {
	group: tr("kaart");
	throwWarning: tr("Gas station has a name but no brand");
}

/* Checks for roundabouts */
way[junction=roundabout] > node {set .is_in_roundabout}
node[traffic_calming=island] { set .is_traffic_calming_island}
way[highway][oneway!=yes][junction!=roundabout] > node.is_in_roundabout!.is_traffic_calming_island {
	group: tr("kaart");
	throwWarning: tr("Highway connecting to roundabout is NOT a oneway -- check if there is a traffic_calming=island nearby");
	suggestAlternative: "Split ways to have roundabout flares or add traffic_calming=island to a node using imagery"
}
way[highway][oneway!=yes][junction!=roundabout] > node.is_in_roundabout.is_traffic_calming_island {
	group: tr("kaart");
	throwWarning: tr("The node where a roundabout and a way connect should NOT be a traffic_calming=island (the island should be on the approach, not in the roundabout)");
}

/* Check for roundabouts with MORE than 1 road entering at the same location */
way[junction=roundabout][name] > node {set .is_in_named_roundabout}
/* TODO remove the one with parent_tags as soon as parent_osm_ids is in josm-tested */
node.is_in_roundabout!.is_in_named_roundabout[count(parent_tags("name")) > 1],
node.is_in_roundabout.is_in_named_roundabout[count(parent_tags("name")) > 2] {
	group: tr("kaart");
	throwWarning: tr("Roundabouts should not have more than two additional ways at any node");
}
node.is_in_roundabout[count(parent_osm_ids("highway")) - count(parent_osm_ids("junction")) > 1] {
	group: tr("kaart");
	throwError: tr("Roundabouts should not have more than two additional ways at any node");
}

/* Ways entering the roundabout should start/end there */
way[name][!junction] > node.is_in_roundabout!.end_of_way!.start_of_way { set .roundabout_way_ends }
node.roundabout_way_ends {
	group: tr("kaart");
	throwWarning: tr("Way {0} does not end at roundabout", parent_tags("name"));
}

way[highway=~/(motorway|trunk|primary|secondary|tertiary|unclassified|residential|service|.*_link)$/][junction!=circular][junction!=roundabout]:closed {
	group: tr("kaart");
	throwWarning: tr("Possible roundabout or circular junction");
}

/* Check destination lane tagging */
/* Check toll roads */
*[destination:ref:lanes=~/(.*)toll(.*)$/] {
	group: tr("kaart");
	throwWarning: tr("Toll roads in destination:ref:lanes are lower case, instead of upper case");
	fixAdd: concat("destination:ref:lanes=", replace(tag("destination:ref:lanes"), "toll", "Toll"));
}

*[destination:ref=~/(.*)toll(.*)$/] {
	group: tr("kaart");
	throwWarning: tr("Toll roads in destination:ref are lower case, instead of upper case");
	fixAdd: concat("destination:ref=", replace(tag("destination:ref"), "toll", "Toll"));
}

*[destination:lanes:ref] {
	group: tr("kaart");
	throwWarning: tr("destination:lanes:ref should be destination:ref:lanes");
	fixChangeKey: "destination:lanes:ref => destination:ref:lanes";
}

*[destination:lanes:ref:to] {
	group: tr("kaart");
	throwWarning: tr("destination:lanes:ref:to should be destination:ref:to:lanes");
	fixChangeKey: "destination:lanes:ref:to => destination:ref:to:lanes";
}

/* TODO: Fix maxspeed maybe parent_tags(key_name) with has_tag_key? */
way[highway][maxspeed] >[index=1] node,
way[highway][maxspeed] >[index=-1] node { set .has_maxspeed }
way[highway][!maxspeed] >[index=1] node,
way[highway][!maxspeed] >[index=-1] node { set .no_maxspeed }
way[highway] <[index=1] node.has_maxspeed { set .start_has_maxspeed }
way[highway] <[index=-1] node.has_maxspeed { set .end_has_maxspeed }

node.no_maxspeed.has_maxspeed[count(parent_tags("name")) = 1],
node.no_maxspeed.has_maxspeed[count(parent_tags("ref")) = 1] {
	group: tr("kaart");
	throwWarning: tr("We go from maxspeed to no maxspeed");
}

way[!maxspeed].start_has_maxspeed!.end_has_maxspeed,
way[!maxspeed]!.start_has_maxspeed.end_has_maxspeed,
way[!maxspeed].start_has_maxspeed.end_has_maxspeed {
	group: tr("kaart");
	throwWarning: tr("Does the maxspeed continue here?");
}
/* Check bridge tagging */
way[highway][bridge][!layer] {
	group: tr("kaart");
	throwWarning: tr("Bridges should have a layer");
	fixAdd: "layer=1";
}

/* Check for potential road restrictions */
way[highway][bridge][!maxweight] {
	group: tr("kaart");
	throwOther: tr("Bridges may have a maxweight");
}
/* TODO fix */
way[highway][bridge] ⧉ way[highway][!bridge][!maxheight] {
	group: tr("kaart");
	throwOther: tr("Bridges occassionally have a maxheight attribute. Check on ground for the information (or OpenStreetCam/Mapillary).");
}
/* Check mini-roundabouts for the correct direction */
node[highway=mini_roundabout][direction!=clockwise]!:righthandtraffic {
	group: tr("kaart");
	throwWarning: tr("Mini-roundabouts should have a clockwise direction in this country");
	fixAdd: "direction=clockwise";
}
node[highway=mini_roundabout][direction!=anticlockwise]:righthandtraffic {
	group: tr("kaart");
	throwWarning: tr("Mini-roundabouts should have a anticlockwise direction in this country");
	fixAdd: "direction=anticlockwise";
}
