meta
{
	title: "Validation rules for Kaart Group";
	version: "2018-11-07"
	description: "Check surfaces on roads that are residential and above, that _link destination:ref tags exist when it has a ref"
	author: "Taylor Smock";
}
/* Check that roads have surfaces */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][name][!surface]{
group: tr("kaart");
throwWarning: tr("Missing surface on road with name");
}
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential|pedestrian)$/][name][surface=paved]{
group: tr("kaart");
throwWarning: tr("Generic paved surface on road with name");
}
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][ref][!surface]{
group: tr("kaart");
throwWarning: tr("Missing surface on road with ref");
}

/* Check that roads have lanes */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|motorway_link|trunk_link|primary_link|secondary_link|tertiary_link)$/][!lanes][!lanes:forward][!lanes:backward]{
group: tr("kaart");
throwWarning: tr("Missing lanes on road");
}

/* Check *_links to make certain they have destination:ref */
way[highway=~/^.*_link$/][ref][!destination:ref] {
group: tr("kaart");
throwWarning: tr("Link has ref but no destination:ref");
fixChangeKey: "ref => destination:ref";
}

/* Check *_links to seeif they have a oneway tag */
way[highway=~/^.*_link$/][!oneway] {
group: tr("kaart");
throwWarning: tr("Links are usually oneways");
}

/* Check for oneway=-1 */
way[oneway=-1] {
throwWarning: tr("Oneways should not use -1. Reverse and use "yes");
}

way[highway=~/^.*_link$/] > node {set .is_in_link}
way[highway =~ /^(bus_guideway|living_street|motorway|motorway_link|pedestrian|primary|primary_link|raceway|residential|road|secondary|secondary_link|service|tertiary|tertiary_link|track|trunk|trunk_link|unclassified)$/] > node { set .is_in_major_road }
way[highway =~ /^(service)$/] > node { set .is_in_minor_road }

/* Mark _links without destination:ref */
way[highway=~/^.*_link$/][!destination:ref][!destination][!destination:street] {
group: tr("kaart");
throwWarning: tr("Link has no destination/:street/:ref tag");
}

/* Copy name to name:<appropriate> */
way[name][!name:el][inside("GR")] {
group: tr("kaart");
throwWarning: tr("There should be a name:el tag");
fixAdd: concat("name:", "el", "=", tag(name));
}

/* Transliteration */
way[name][!int_name] {
group: tr("kaart");
throwWarning: tr("There should be an int_name");
fixAdd: concat("int_name=", tag(name));
}
/* Greece transliteration */
/**/
way[int_name=~/^(.*)(Α|α|ά|Β|β|Γ|γ|Δ|δ|Ε|ε|Ζ|ζ|Η|η|Θ|θ|Ι|ι|Κ|κ|Λ|λ|Μ|μ|Ν|ν|Ξ|ξ|Ο|ο|Π|π|Ρ|ρ|Σ|σ|ς|Τ|τ|Υ|υ|Φ|φ|Χ|χ|Ψ|ψ|Ω|ω)+(.*)$/][inside("GR")] {
group: tr("kaart");
throwWarning: "int_name shouldn't be the local greece name";
fixAdd: concat("int_name=", replace(tag("int_name"), "Α", "A"));
fixAdd: concat("int_name=", replace(tag("int_name"), "α", "a"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ά", "a"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Β", "B"));
fixAdd: concat("int_name=", replace(tag("int_name"), "β", "b"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Γ", "G"));
fixAdd: concat("int_name=", replace(tag("int_name"), "γ", "g"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Δ", "D"));
fixAdd: concat("int_name=", replace(tag("int_name"), "δ", "d"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Ε", "E"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ε", "e"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Ζ", "Z"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ζ", "z"));
/*fixAdd: concat("int_name=", replace(tag("int_name"), "Η", "TODO"));*/
/*fixAdd: concat("int_name=", replace(tag("int_name"), "η", "TODO"));*/
fixAdd: concat("int_name=", replace(tag("int_name"), "Θ", "Th"));
fixAdd: concat("int_name=", replace(tag("int_name"), "θ", "th"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Ι", "I"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ι", "i"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Κ", "K"));
fixAdd: concat("int_name=", replace(tag("int_name"), "κ", "k"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Λ", "L"));
fixAdd: concat("int_name=", replace(tag("int_name"), "λ", "l"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Μ", "M"));
fixAdd: concat("int_name=", replace(tag("int_name"), "μ", "m"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Ν", "N"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ν", "n"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Ξ", "X"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ξ", "x"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Ο", "O"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ο", "o"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Π", "P"));
fixAdd: concat("int_name=", replace(tag("int_name"), "π", "p"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Ρ", "R"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ρ", "r"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Σ", "S"));
fixAdd: concat("int_name=", replace(tag("int_name"), "σς", "s"));
fixAdd: concat("int_name=", replace(tag("int_name"), "σ", "s"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ς", "s"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Τ", "t"));
fixAdd: concat("int_name=", replace(tag("int_name"), "τ", "t"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Υ", "U"));
fixAdd: concat("int_name=", replace(tag("int_name"), "υ", "u"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Φ", "Ph"));
fixAdd: concat("int_name=", replace(tag("int_name"), "φ", "ph"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Χ", "Ch"));
fixAdd: concat("int_name=", replace(tag("int_name"), "χ", "ch"));
fixAdd: concat("int_name=", replace(tag("int_name"), "Ψ", "Ps"));
fixAdd: concat("int_name=", replace(tag("int_name"), "ψ", "ps"));
/*fixAdd: concat("int_name=", replace(tag("int_name"), "Ω", "TODO"));*/
/*fixAdd: concat("int_name=", replace(tag("int_name"), "ω", "TODO"));*/
}

/* OSM Greece does NOT want street/road TODO fix */
way[highway][name=~/^(.*)(Οδός|Odos|Λεωφόρος|avenue|street|road)$/][inside("GR")],
way[highway][name:en=~/^(.*)(avenue|street|road)$/][inside("GR")],
way[highway][name:el=~/^(.*)(Οδός|Odos|Λεωφόρος)$/][inside("GR")] {
group: tr("kaart");
throwWarning: "OSM Greece does not want street/road/other prefixes";
assertMatch: "way highway=primary name=\"Fessa street\"";
assertMatch: "way highway=primary name:en=\"Fessa street\"";
fixAdd: concat("name:en=", replace(tag("name:en"), "street", ""));
fixAdd: concat("name:en=", replace(tag("name:en"), "avenue", ""));
fixAdd: concat("name:en=", replace(tag("name:en"), "road", ""));
}
/* Mark gas stations without a brand but with a common brand name */
*[amenity=fuel][name=~/(BP|Caltex|Engen|Sasol|Shell|Total)$/][!brand] {
group: tr("kaart");
throwWarning: tr("Gas station has a name but no brand");
fixChangeKey: "name => brand";
}

/* Mark gas stations without a brand */
*[amenity=fuel][name][!brand] {
group: tr("kaart");
throwWarning: tr("Gas station has a name but no brand");
}

/* Checks for roundabouts */
way[junction=roundabout] > node {set .is_in_roundabout}
node[traffic_calming=island] { set .is_traffic_calming_island}
way[highway][oneway!=yes][junction!=roundabout] > node.is_in_roundabout!.is_traffic_calming_island {
group: tr("kaart");
throwWarning: tr("Highway connecting to roundabout is NOT a oneway and the node is not a traffic calming island");
suggestAlternative: "Split ways to have roundabout flares or add traffic_calming=island to the node"
}

way[highway=~/(motorway|trunk|primary|secondary|tertiary|unclassified|residential|service|.*_link)$/][junction!=circular][junction!=roundabout]:closed {
group: tr("kaart");
throwWarning: tr("Possible roundabout or circular junction");
}

/* Check destination lane tagging */
/* Check toll roads */
*[destination:ref:lanes=~/(.*)toll(.*)$/] {
group: tr("kaart");
throwWarning: tr("Toll roads in destination:ref:lanes are lower case, instead of upper case");
fixAdd: concat("destination:ref:lanes=", replace(tag("destination:ref:lanes"), "toll", "Toll"));
}

*[destination:ref=~/(.*)toll(.*)$/] {
group: tr("kaart");
throwWarning: tr("Toll roads in destination:ref are lower case, instead of upper case");
fixAdd: concat("destination:ref=", replace(tag("destination:ref"), "toll", "Toll"));
}

*[destination:lanes:ref] {
group: tr("kaart");
throwWarning: tr("destination:lanes:ref should be destination:ref:lanes");
fixChangeKey: "destination:lanes:ref => destination:ref:lanes";
}

*[destination:lanes:ref:to] {
group: tr("kaart");
throwWarning: tr("destination:lanes:ref:to should be destination:ref:to:lanes");
fixChangeKey: "destination:lanes:ref:to => destination:ref:to:lanes";
}

/* TODO: Fix maxspeed maybe parent_tags(key_name) with has_tag_key? */
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][maxspeed] > node:connection { set .has_maxspeed }
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/][!maxspeed] > node:connection { set .no_maxspeed }
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/] >[index=1] node.has_maxspeed { set .start_has_maxspeed }
way[highway=~/^(motorway|trunk|primary|secondary|tertiary|residential)$/] >[index=-1] node.has_maxspeed { set .end_has_maxspeed }

way[!maxspeed].start_has_maxspeed!.end_has_maxspeed,
way[!maxspeed]!.start_has_maxspeed.end_has_maxspeed,
way[!maxspeed].start_has_maxspeed.end_has_maxspeed {
group: tr("kaart");
throwOther: tr("Does the maxspeed continue here?");
}
/* Check bridge tagging */
way[bridge][!layer] {
group: tr("kaart");
throwWarning: tr("Bridges should have a layer");
fixAdd: "layer=1";
}

/* Check mini-roundabouts for the correct direction */
node[highway=mini_roundabout][direction!=clockwise]!:righthandtraffic {
group: tr("kaart");
throwWarning: tr("Mini-roundabouts should have a clockwise direction in this country");
fixAdd: "direction=clockwise";
}
node[highway=mini_roundabout][direction!=anticlockwise]:righthandtraffic {
group: tr("kaart");
throwWarning: tr("Mini-roundabouts should have a anticlockwise direction in this country");
fixAdd: "direction=anticlockwise";
}
